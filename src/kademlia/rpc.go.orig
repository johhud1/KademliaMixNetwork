package kademlia
// Contains definitions mirroring the Kademlia spec. You will need to stick
// strictly to these to be compatible with the reference implementation and
// other groups' code.




/* PING
 * This RPC involves one node sending a PING message to another, which presumably replies with a PONG.
 * This has a two-fold effect: the recipient of the PING must update the bucket corresponding to the sender;
 * and, if there is a reply, the sender must update the bucket appropriate to the recipient.
 * All RPC packets are required to carry an RPC identifier assigned by the sender and echoed in the reply.
 * This is a quasi-random number of length B (160 bits).
 * 
 * Implementations using shorter message identifiers must consider the birthday paradox, which in effect 
 * makes the probability of a collision depend upon half the number of bits in the identifier. For example, 
 * a 32-bit RPC identifier would yield a probability of collision proportional to 2^-16, an uncomfortably 
 * small number in a busy network.
 * 
 * If the identifiers are initialized to zero or are generated by the same random number generator 
 * with the same seed, the probability will be very high indeed. 
 * 
 * It must be possible to piggyback PINGs onto RPC replies to force or permit the originator, the sender 
 * of the RPC, to provide additional information to its recipient. This might be a different IP address or 
 * a preferred protocol for future communications.
 * 
 */
type Ping struct {
     NodeID ID
     MsgID ID
}

type Pong struct {
     NodeID ID
     MsgID ID
}

func (k *Kademlia) Ping(ping Ping, pong *Pong) error {

     //TODO: UPDATA BUCKET REGARDING ping.NodeID

     pong.NodeID = CopyID(k.NodeID)
     pong.MsgID = CopyID(ping.MsgID)
     return nil
}


/* STORE
 * The sender of the STORE RPC provides a key and a block of data and
 * requires that the recipient store the data and make it available for later retrieval by that key.
 *
 * This is a primitive operation, not an iterative one.
 *
 * While this is not formally specified, it is clear that the initial STORE message must contain
 * in addition to the message ID at least the data to be stored (including its length) and the associated key.
 * As the transport may be UDP, the message needs to also contain at least the nodeID of the sender, and the 
 * reply the nodeID of the recipient.
 *
 * The reply to any RPC should also contain an indication of the result of the operation. For example, in a STORE 
 * while no maximum data length has been specified, it is clearly possible that the receiver might not be able 
 * to store the data, either because of lack of space or because of an I/O error. 
 *
 *
 */
type StoreRequest struct {
     NodeID ID //ID of the sender
     MsgID ID  
     Key ID
     Value []byte
}

type StoreResult struct {
    NodeID ID //ID of the responder
    MsgID ID
    Err error
}

func (k *Kademlia) Store(req StoreRequest, res *StoreResult) error {
    // TODO: Implement.

    ///Update contact information for the sender
    ///CHECK IF WE ACTUALLY NEED ΤΟ DO THAT (PUT A REFERENCE ON WHERE THIS IS SPECIFIED IN THE PAPER)


    ///Try to store the data into a hash map
    //data[req.Key] = req.Value

    //res.NodeID = CopyID(k.NodeID)
    //res.MsgID = CopyID(req.MsgID)

    ///if the store fails create and error
    //if NO_MORE_SPACE {
    //	 res.Err = errors.New("No space to perform the store.")
    //}
 
    return nil
}


/* FIND_NODE
 * The FIND_NODE RPC includes a 160-bit key. The recipient of the RPC returns up to k triples 
 * (IP address, port, nodeID) for the contacts that it knows to be closest to the key.
 * The recipient must return k triples if at all possible. It may only return fewer than k 
 * if it is returning all of the contacts that it has knowledge of.
 * This is a primitive operation, not an iterative one.
 *
 * The name of this RPC is misleading. Even if the key to the RPC is the nodeID of an existing contact 
 * or indeed if it is the nodeID of the recipient itself, the recipient is still required to return k triples.
 *  A more descriptive name would be FIND_CLOSE_NODES.
 * The recipient of a FIND_NODE should never return a triple containing the nodeID of the requestor. 
 * If the requestor does receive such a triple, it should discard it. A node must never put its own nodeID 
 * into a bucket as a contact. 
 *
 */
type FindNodeRequest struct {
    MsgID ID
    NodeID ID
}

type FoundNode struct {
    IPAddr string
    Port uint16
    NodeID ID
}

type FindNodeResult struct {
    MsgID ID
    Nodes []FoundNode
    Err error
}

func (k *Kademlia) FindNode(req FindNodeRequest, res *FindNodeResult) error {
    // TODO: Implement.


    return nil
}


/* FIND_VALUE
 */
type FindValueRequest struct {
    MsgID ID
    Key ID
}

// If Value is nil, it should be ignored, and Nodes means the same as in a
// FindNodeResult.
type FindValueResult struct {
    MsgID ID
    Value []byte
    Nodes []FoundNode
    Err error
}

func (k *Kademlia) FindValue(req FindValueRequest, res *FindValueResult) error {
    // TODO: Implement.

    
    return nil
}

